# AGI-Walker 测试与验证指南

本指南说明如何全面测试和验证AGI-Walker系统。

---

## 🎯 测试目标

1. ✅ 验证TCP通信稳定性
2. ✅ 测试PID平衡控制效果
3. ✅ 验证物理参数优化
4. ✅ 测试系统性能
5. ✅ 生成测试报告

---

## 🚀 快速开始

### 准备工作

1. **启动Godot仿真**
   - 打开Godot项目
   - 按F5运行主场景
   - 确认控制台显示: `✅ TCP服务器已启动`

2. **检查Python环境**
   ```bash
   cd python_controller
   # 无需额外依赖，使用Python标准库
   ```

### 运行完整测试

```bash
python test_suite.py
```

---

## 📋 测试清单

### 1. TCP通信测试

**运行测试**:
```bash
python test_latency.py
```

**验收标准**:
- ✅ 平均延迟 < 10ms
- ✅ 丢包率 < 1%
- ✅ 数据格式100%正确

**预期输出**:
```
平均延迟: 5.23ms
中位数: 4.98ms  
最大值: 12.34ms
P95: 8.72ms
```

---

### 2. PID平衡控制测试

**运行测试**:
```bash
python test_pid_balance.py
```

**测试流程**:

#### 步骤1: 基准测试（无PID）
1. 在Godot中，将`BalanceController`节点的`enabled`设为`false`
2. 运行测试，记录机器人自然状态

#### 步骤2: PID控制测试
1. 将`BalanceController`的`enabled`设为`true`
2. 运行测试，对比改进效果

**验收标准**:
- ✅ 站立时间 > 30秒（有PID）
- ✅ 平均倾斜角 < 10° （有PID）
- ✅ PID评分 > 无PID评分

**预期对比**:
```
排名   测试名称                评分        平均倾斜    持续
1     PID控制-默认参数        92.3/100    4.52°      30.0s
2     基准测试-无PID          35.8/100    18.34°     6.2s
```

---

### 3. 物理参数验证

**运行测试**:
```bash
python physics_tuner.py
```

**测试项目**:
- 稳定性评分
- 电机响应速度
- 摩擦力效果

**验收标准**:
- ✅ 稳定性评分 > 85/100
- ✅ 电机响应时间 < 0.5s
- ✅ 无明显滑动

---

### 4. 系统集成测试

**运行测试**:
```bash
python test_suite.py
```

**测试覆盖**:
- TCP连接建立
- 通信延迟
- 数据完整性
- 站立稳定性
- 控制频率

**验收标准**:
- ✅ 所有测试通过
- ✅ 成功率 100%

---

## 📊 性能基准

### 目标指标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| **TCP延迟** | < 10ms | 平均往返时间 |
| **控制频率** | ≥ 20Hz | 实际控制循环频率 |
| **站立时间** | > 30s | 启用PID后 |
| **平均倾斜** | < 10° | Roll+Pitch总和 |
| **稳定性评分** | > 85/100 | 综合评价 |

### 实际测试结果

运行测试后，在这里记录您的结果：

| 指标 | 实际值 | 状态 | 备注 |
|------|--------|------|------|
| TCP延迟 | ___ ms | ⏳ | |
| 控制频率 | ___ Hz | ⏳ | |
| 站立时间 | ___ s | ⏳ | |
| 平均倾斜 | ___ ° | ⏳ | |
| 稳定性评分 | ___ /100 | ⏳ | |

---

## 🔍 详细测试步骤

### 测试1: 最小系统测试

**目标**: 验证基本通信

```bash
# 1. 启动Godot
# 2. 运行简单客户端
python tcp_client.py
```

**检查点**:
- [ ] 能够连接
- [ ] 接收到传感器数据
- [ ] 数据格式正确
- [ ] 发送命令成功

---

### 测试2: 延迟压力测试

**目标**: 验证高频通信

```bash
python test_latency.py
```

**观察**:
- 延迟分布
- 是否有丢包
- 抖动情况

**如果延迟过高**:
- 检查网络（虽然是本地）
- 关闭其他占用CPU的程序
- 优化Godot物理设置

---

### 测试3: PID参数影响

**目标**: 验证PID控制效果

**步骤**:
1. 记录无PID时的表现
2. 启用PID，使用默认参数
3. 对比数据

**分析指标**:
- 倾斜角减少幅度
- 站立时间提升
- 震荡情况

---

### 测试4: 长时间稳定性

**目标**: 验证系统可靠性

```bash
python -c "
from tcp_client import GodotClient
import time

client = GodotClient()
client.connect()

start = time.time()
while time.time() - start < 300:  # 5分钟
    sensor = client.get_latest_sensors()
    if sensor:
        print(f'[{time.time()-start:5.0f}s] OK')
    time.sleep(1)
"
```

**验收**:
- [ ] 无断连
- [ ] 无数据异常
- [ ] Godot无崩溃

---

## 📈 测试报告模板

测试完成后，填写以下报告：

### 测试环境

- **日期**: ___________
- **Godot版本**: ___________
- **Python版本**: ___________
- **操作系统**: ___________

### 测试结果

#### TCP通信 ✅/❌
- 平均延迟: ___ ms
- 成功率: ___ %
- 备注: ___________

#### PID平衡控制 ✅/❌
- 无PID评分: ___ /100
- 有PID评分: ___ /100
- 改进幅度: ___ %
- 备注: ___________

#### 系统性能 ✅/❌
- 控制频率: ___ Hz
- 稳定性: ___ /100
- 备注: ___________

### 发现的问题

1. ___________
2. ___________

### 改进建议

1. ___________
2. ___________

---

## 🛠️ 故障排除

### 问题1: 无法连接到Godot

**症状**:
```
❌ 无法连接到Godot仿真器
```

**解决**:
1. 确认Godot正在运行
2. 检查控制台是否显示TCP服务器启动
3. 确认端口9999未被占用
4. 重启Godot

### 问题2: 延迟过高

**症状**: 延迟 > 20ms

**解决**:
1. 关闭其他程序
2. 降低Godot渲染质量
3. 检查是否使用集成显卡

### 问题3: 机器人立即摔倒

**原因**:
- 物理参数不当
- 关节未正确配置
- 质量分布不合理

**解决**:
1. 检查关节是否正确连接
2. 运行`physics_tuner.py`优化参数
3. 查看`OPTIMIZATION_GUIDE.md`

### 问题4: PID控制无效

**检查**:
1. BalanceController是否启用
2. PID参数是否合理
3. 关节电机是否工作

---

## 🎓 进阶测试

### 自定义测试场景

创建您自己的测试脚本：

```python
from tcp_client import GodotClient
import time

client = GodotClient()
client.connect()

# 您的测试逻辑
for i in range(100):
    sensor = client.get_latest_sensors()
    # 分析、记录、验证...
    time.sleep(0.01)

client.close()
```

### 参数扫描测试

使用`pid_tuner.py`自动测试多组参数：

```bash
python pid_tuner.py
# 选择: 1 (网格搜索)
```

---

## ✅ 验收检查表

完成测试后，确认以下项目：

- [ ] TCP通信延迟 < 10ms
- [ ] 数据完整性 100%
- [ ] 站立时间 > 30s（有PID）
- [ ] 平均倾斜 < 10°
- [ ] 控制频率 > 20Hz
- [ ] 无系统崩溃
- [ ] 测试报告已生成

全部通过后，系统已准备进入下一阶段！

---

> 💡 **提示**: 保存所有测试报告JSON文件，用于后续分析和优化。
